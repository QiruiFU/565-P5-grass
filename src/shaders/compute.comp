#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform CameraBufferObject {
    mat4 view;
    mat4 proj;
} camera;

layout(set = 1, binding = 0) uniform Time {
    float deltaTime;
    float totalTime;
};

struct Blade {
    vec4 v0;
    vec4 v1;
    vec4 v2;
    vec4 up;
};

// TODO: Add bindings to:
// 1. Store the input blades
// 2. Write out the culled blades
// 3. Write the total number of blades remaining

// The project is using vkCmdDrawIndirect to use a buffer as the arguments for a draw call
// This is sort of an advanced feature so we've showed you what this buffer should look like
//
// layout(set = ???, binding = ???) buffer NumBlades {
// 	  uint vertexCount;   // Write the number of blades remaining here
// 	  uint instanceCount; // = 1
// 	  uint firstVertex;   // = 0
// 	  uint firstInstance; // = 0
// } numBlades;

layout(set = 2, binding = 0) buffer Blades {
    Blade blades[];
};

layout(set = 2, binding = 1) buffer CulledBlades {
    Blade culledBlades[];
};

layout(set = 2, binding = 2) buffer BladeInfo {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
} bladeInfo;

bool inBounds(float value, float bounds) {
    return (value >= -bounds) && (value <= bounds);
}

void main() {
	// Reset the number of blades to 0
	if (gl_GlobalInvocationID.x == 0) {
		bladeInfo.vertexCount = 0;
	}
	barrier(); // Wait till all threads reach this point

    // TODO: Apply forces on every blade and update the vertices in the buffer

	// TODO: Cull blades that are too far away or not in the camera frustum and write them
	// to the culled blades buffer
	// Note: to do this, you will need to use an atomic operation to read and update numBlades.vertexCount
	// You want to write the visible blades to the buffer without write conflicts between threads
    
    Blade blade = blades[gl_GlobalInvocationID.x];

    const float g = 5.0;
    const float wind = 3.0;
    const float wind_freq = 1.5;

    const float orientation = 0.4;
    const int bucket = 5;
    const float max_dis = 15.0;

    vec3 v0 = blade.v0.xyz;
    vec3 v1 = blade.v1.xyz;
    vec3 v2 = blade.v2.xyz;
    vec3 up = blade.up.xyz;
    float blade_orient = blade.v0.w;
    float height = blade.v1.w;
    float stiffness = blade.up.w;

    // gravity
    vec3 t1 = normalize(vec3(-cos(blade_orient), 0.0, sin(blade_orient)));
    vec3 f = normalize(cross(t1, up));
    vec3 g_total = vec3(0.0, -g, 0.0) + 0.25 * g * f;

    // stiffness
    vec3 iv2 = v0 + height * up;
    vec3 re = (iv2 - v2) * stiffness;

    // wind
    vec3 windDir = wind * vec3(cos(wind_freq * v0.x * totalTime), 0.0, sin(wind_freq * v0.z * totalTime));
    float fd = 1.0 - abs(dot(normalize(windDir), normalize(v2 - v0)));
    float fr = dot(v2 - v0, up) / height;
    vec3 w = windDir * (fd * fr);

    v2 += (g_total + re + w) * deltaTime;
    v2 -= up * min(dot(up, v2 - v0), 0.0);

    float lproj = length(v2 - v0 - up * dot(v2 - v0, up));
    v1 = v0 + height * up * max(1.0 - lproj / height, 0.05 * max(lproj / height, 1.0));

    float L0 = distance(v0, v2);
    float L1 = distance(v0, v1) + distance(v1, v2);
    float r = height / ((2.0 * L0 + L1) / 3.0);

    v1 = v0 + r * (v1 - v0);
    v2 = v1 + r * (v2 - v1);

    blade.v1.xyz = v1;
    blade.v2.xyz = v2;

    blades[gl_GlobalInvocationID.x] = blade;
    
    // frustum
    vec4 ccs_v0 = camera.proj * camera.view * vec4(v0, 1.0);
    vec4 ccs_v2 = camera.proj * camera.view * vec4(v2, 1.0);
    vec4 ccs_m  = camera.proj * camera.view * vec4((1.0/4.0)*v0 + (1.0/2.0)*v1 + (1.0/4.0)*v2, 1.0);

    bool v0_in = abs(ccs_v0.x) <= ccs_v0.w && abs(ccs_v0.y) <= ccs_v0.w && abs(ccs_v0.z) <= ccs_v0.w;
    bool v2_in = abs(ccs_v2.x) <= ccs_v2.w && abs(ccs_v2.y) <= ccs_v2.w && abs(ccs_v2.z) <= ccs_v2.w;
    bool m_in  = abs(ccs_m.x)  <= ccs_m.w  && abs(ccs_m.y)  <= ccs_m.w  && abs(ccs_m.z)  <= ccs_m.w;

    if (!v0_in && !v2_in && !m_in) {
        return;
    }

    // camera
    vec3 camPos = inverse(camera.view)[3].xyz;
    vec3 camToBlade = v0 - camPos;
    vec3 viewDir = camToBlade - up * dot(camToBlade, up);

    float angle = abs(dot(normalize(viewDir), t1));
    if (angle < orientation) {
        return;
    }

    // distance
    float dproj = length(viewDir);
    if ((gl_GlobalInvocationID.x % bucket) < int(floor(bucket * (1.0 - dproj / max_dis)))) {
        return;
    }

    culledBlades[atomicAdd(bladeInfo.vertexCount, 1)] = blade;
}
